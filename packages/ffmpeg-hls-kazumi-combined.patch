diff --git a/libavformat/hls.c b/libavformat/hls.c
index 22ee1c6..d23c0f5 100644
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -84,6 +84,8 @@ struct segment {
     uint8_t iv[16];
     /* associated Media Initialization Section, treated as a segment */
     struct segment *init_section;
+    /* Kazumi: Segment follows a DISCONTINUITY tag */
+    int after_discontinuity;
 };
 
 struct rendition;
@@ -223,6 +225,7 @@ typedef struct HLSContext {
     AVIOInterruptCB *interrupt_callback;
     AVDictionary *avio_opts;
     AVDictionary *seg_format_opts;
+    int seg_allow_img;
     char *allowed_extensions;
     char *allowed_segment_extensions;
     int extension_picky;
@@ -233,6 +236,21 @@ typedef struct HLSContext {
     int seg_max_retry;
     AVIOContext *playlist_pb;
     HLSCryptoContext  crypto_ctx;
+    /* Kazumi: Ad filtering based on PTS discontinuity */
+    int hls_ad_filter;              /* Enable PTS-based ad filtering */
+    int has_discontinuity;          /* M3U8 contains #EXT-X-DISCONTINUITY */
+    int64_t last_main_pts;          /* Last PTS from main content (video) */
+    int64_t last_main_audio_pts;    /* Last PTS from main content (audio) */
+    int in_ad_segment;              /* Currently in ad segment */
+    int after_seek;                 /* Flag to ignore PTS jump after seek */
+    /* Kazumi: PTS offset approach for seamless playback */
+    int64_t pts_offset;             /* Current PTS offset to apply */
+    int64_t ad_start_video_pts;     /* Video PTS when ad started (before offset) */
+    int64_t ad_start_audio_pts;     /* Audio PTS when ad started (before offset) */
+    int64_t ad_resume_video_pts;    /* Video PTS when resuming from ad */
+    int64_t ad_resume_audio_pts;    /* Audio PTS when resuming from ad */
+    int video_resumed;              /* Video has resumed from ad */
+    int audio_resumed;              /* Audio has resumed from ad */
 } HLSContext;
 
 static void free_segment_dynarray(struct segment **segments, int n_segments)
@@ -802,6 +820,8 @@ static int parse_playlist(HLSContext *c, const char *url,
     struct segment **prev_segments = NULL;
     int prev_n_segments = 0;
     int64_t prev_start_seq_no = -1;
+    /* Kazumi: Track if next segment follows DISCONTINUITY */
+    int next_seg_after_discontinuity = 0;
 
     if (is_http && !in && c->http_persistent && c->playlist_pb) {
         in = c->playlist_pb;
@@ -967,6 +987,15 @@ static int parse_playlist(HLSContext *c, const char *url,
         } else if (av_strstart(line, "#EXT-X-ENDLIST", &ptr)) {
             if (pls)
                 pls->finished = 1;
+        } else if (av_strstart(line, "#EXT-X-DISCONTINUITY", NULL)) {
+            /* Kazumi: Mark that stream has discontinuity and next segment follows it */
+            if (c->hls_ad_filter) {
+                if (!c->has_discontinuity) {
+                    c->has_discontinuity = 1;
+                    av_log(c->ctx, AV_LOG_INFO, "Kazumi: Stream has DISCONTINUITY tags, ad filtering enabled\n");
+                }
+                next_seg_after_discontinuity = 1;
+            }
         } else if (av_strstart(line, "#EXTINF:", &ptr)) {
             is_segment = 1;
             duration   = atof(ptr) * AV_TIME_BASE;
@@ -1066,6 +1095,9 @@ static int parse_playlist(HLSContext *c, const char *url,
                 }
 
                 seg->init_section = cur_init_section;
+                /* Kazumi: Mark segment as following discontinuity */
+                seg->after_discontinuity = next_seg_after_discontinuity;
+                next_seg_after_discontinuity = 0;
             }
         }
     }
@@ -2132,6 +2164,11 @@ static int hls_read_header(AVFormatContext *s)
     c->first_packet = 1;
     c->first_timestamp = AV_NOPTS_VALUE;
     c->cur_timestamp = AV_NOPTS_VALUE;
+    /* Kazumi: Initialize ad filtering state */
+    c->last_main_pts = AV_NOPTS_VALUE;
+    c->last_main_audio_pts = AV_NOPTS_VALUE;
+    c->ad_start_video_pts = AV_NOPTS_VALUE;
+    c->ad_start_audio_pts = AV_NOPTS_VALUE;
 
     if ((ret = ffio_copy_url_options(s->pb, &c->avio_opts)) < 0)
         return ret;
@@ -2308,12 +2345,34 @@ static int hls_read_header(AVFormatContext *s)
             in_fmt = av_find_input_format(pls->audio_setup_info.codec_id == AV_CODEC_ID_AAC ? "aac" :
                                           pls->audio_setup_info.codec_id == AV_CODEC_ID_AC3 ? "ac3" : "eac3");
         } else {
+            unsigned skip = 0;
             pls->ctx->probesize = s->probesize > 0 ? s->probesize : 1024 * 4;
             pls->ctx->max_analyze_duration = s->max_analyze_duration > 0 ? s->max_analyze_duration : 4 * AV_TIME_BASE;
             pls->ctx->interrupt_callback = s->interrupt_callback;
             url = av_strdup(pls->segments[0]->url);
-            ret = av_probe_input_buffer(&pls->pb.pub, &in_fmt, url, NULL, 0, 0);
-
+            if (!c->seg_allow_img) {
+                uint8_t b[10] = { 0 };
+                int max_score = AVPROBE_SCORE_MAX - 2;
+                const AVInputFormat* img_fmt;
+                AVProbeData pd;
+                avio_read(&pls->pb.pub, b, sizeof(b));
+                avio_seek(&pls->pb.pub, 0, SEEK_SET);
+                pd.buf = b;
+                pd.buf_size = sizeof(b);
+                pd.filename = NULL;
+                pd.mime_type = NULL;
+                img_fmt = av_probe_input_format2(&pd, 1, &max_score);
+                if (img_fmt) {
+                    if (av_strstart(img_fmt->name, "png", NULL)) {
+                        skip = 3;
+                        av_log(s, AV_LOG_INFO, "segments pretend to be png\n");
+                    } else if (av_strstart(img_fmt->name, "gif", NULL)) {
+                        skip = 10;
+                        av_log(s, AV_LOG_INFO, "segments pretend to be gif\n");
+                    }
+                }
+            }
+            ret = av_probe_input_buffer(&pls->pb.pub, &in_fmt, url, NULL, skip, 0);
             for (int n = 0; n < pls->n_segments; n++)
                 if (ret >= 0)
                     ret = test_segment(s, in_fmt, pls, pls->segments[n]);
@@ -2544,6 +2603,114 @@ static int hls_read_packet(AVFormatContext *s, AVPacket *pkt)
                 }
 
                 seg = current_segment(pls);
+
+                /* Kazumi: PTS-based ad filtering with offset adjustment */
+                if (c->hls_ad_filter && c->has_discontinuity) {
+                    enum AVMediaType pkt_type = pls->ctx->streams[pls->pkt->stream_index]->codecpar->codec_type;
+                    int is_video = (pkt_type == AVMEDIA_TYPE_VIDEO);
+                    int is_audio = (pkt_type == AVMEDIA_TYPE_AUDIO);
+                    int64_t current_pts = pls->pkt->pts != AV_NOPTS_VALUE ? pls->pkt->pts : pls->pkt->dts;
+                    int64_t pts_in_us = AV_NOPTS_VALUE;
+
+                    if (current_pts != AV_NOPTS_VALUE) {
+                        AVRational pkt_tb = pls->ctx->streams[pls->pkt->stream_index]->time_base;
+                        pts_in_us = av_rescale_q(current_pts, pkt_tb, AV_TIME_BASE_Q);
+                    }
+
+                    /* Phase 1: In ad segment - drop packets and wait for return */
+                    if (c->in_ad_segment) {
+                        if (pts_in_us != AV_NOPTS_VALUE) {
+                            int64_t ref_pts = c->ad_start_video_pts;
+                            int64_t pts_diff;
+                            if (ref_pts == AV_NOPTS_VALUE) ref_pts = c->ad_start_audio_pts;
+                            pts_diff = pts_in_us - ref_pts;
+
+                            /* Check if returned to main content PTS range */
+                            if (pts_diff > -2000000 && pts_diff < 10000000) {
+                                /* Resuming from ad */
+                                if (is_video && !c->video_resumed) {
+                                    c->video_resumed = 1;
+                                    c->ad_resume_video_pts = pts_in_us;
+                                    av_log(c->ctx, AV_LOG_INFO, "Kazumi: Video resuming at PTS=%"PRId64"ms\n", pts_in_us/1000);
+                                }
+                                if (is_audio && !c->audio_resumed) {
+                                    c->audio_resumed = 1;
+                                    c->ad_resume_audio_pts = pts_in_us;
+                                    av_log(c->ctx, AV_LOG_INFO, "Kazumi: Audio resuming at PTS=%"PRId64"ms\n", pts_in_us/1000);
+                                }
+
+                                /* When both tracks resumed, calculate and apply offset */
+                                if (c->video_resumed && c->audio_resumed) {
+                                    int64_t video_gap = c->ad_resume_video_pts - c->ad_start_video_pts;
+                                    c->pts_offset -= video_gap;
+                                    av_log(c->ctx, AV_LOG_INFO, "Kazumi: Ad skipped! Offset adjusted by %"PRId64"ms, total offset=%"PRId64"ms\n",
+                                           -video_gap/1000, c->pts_offset/1000);
+                                    c->in_ad_segment = 0;
+                                }
+
+                                /* Apply offset and let packet through */
+                                if (c->pts_offset != 0 && pls->pkt->pts != AV_NOPTS_VALUE) {
+                                    AVRational pkt_tb = pls->ctx->streams[pls->pkt->stream_index]->time_base;
+                                    int64_t offset_in_tb = av_rescale_q(c->pts_offset, AV_TIME_BASE_Q, pkt_tb);
+                                    pls->pkt->pts += offset_in_tb;
+                                    if (pls->pkt->dts != AV_NOPTS_VALUE)
+                                        pls->pkt->dts += offset_in_tb;
+                                }
+                                /* Update tracking */
+                                if (is_video) c->last_main_pts = pts_in_us + c->pts_offset;
+                                if (is_audio) c->last_main_audio_pts = pts_in_us + c->pts_offset;
+                            } else {
+                                /* Still in ad content, drop packet */
+                                av_packet_unref(pls->pkt);
+                                continue;
+                            }
+                        } else {
+                            /* No PTS, drop packet */
+                            av_packet_unref(pls->pkt);
+                            continue;
+                        }
+                    }
+                    /* Phase 2: Normal playback - detect ad and apply offset */
+                    else {
+                        if (pts_in_us != AV_NOPTS_VALUE) {
+                            if (c->after_seek) {
+                                if (is_video) c->last_main_pts = pts_in_us;
+                                if (is_audio) c->last_main_audio_pts = pts_in_us;
+                                c->after_seek = 0;
+                                c->pts_offset = 0;
+                            } else if (is_video && c->last_main_pts != AV_NOPTS_VALUE) {
+                                int64_t pts_diff = pts_in_us - (c->last_main_pts - c->pts_offset);
+
+                                /* Ad detection: PTS jumps backward significantly (> 1 sec) */
+                                if (pts_diff < -1000000) {
+                                    c->in_ad_segment = 1;
+                                    c->video_resumed = 0;
+                                    c->audio_resumed = 0;
+                                    c->ad_start_video_pts = c->last_main_pts - c->pts_offset;
+                                    c->ad_start_audio_pts = c->last_main_audio_pts - c->pts_offset;
+                                    av_log(c->ctx, AV_LOG_INFO, "Kazumi: Ad detected! PTS jumped from %"PRId64"ms to %"PRId64"ms\n",
+                                           (c->last_main_pts - c->pts_offset)/1000, pts_in_us/1000);
+                                    av_packet_unref(pls->pkt);
+                                    continue;
+                                }
+                            }
+
+                            /* Apply offset if any */
+                            if (c->pts_offset != 0 && pls->pkt->pts != AV_NOPTS_VALUE) {
+                                AVRational pkt_tb = pls->ctx->streams[pls->pkt->stream_index]->time_base;
+                                int64_t offset_in_tb = av_rescale_q(c->pts_offset, AV_TIME_BASE_Q, pkt_tb);
+                                pls->pkt->pts += offset_in_tb;
+                                if (pls->pkt->dts != AV_NOPTS_VALUE)
+                                    pls->pkt->dts += offset_in_tb;
+                            }
+
+                            /* Update tracking */
+                            if (is_video) c->last_main_pts = pts_in_us + c->pts_offset;
+                            if (is_audio) c->last_main_audio_pts = pts_in_us + c->pts_offset;
+                        }
+                    }
+                }
+
                 if (seg && seg->key_type == KEY_SAMPLE_AES && !strstr(pls->ctx->iformat->name, "mov")) {
                     enum AVCodecID codec_id = pls->ctx->streams[pls->pkt->stream_index]->codecpar->codec_id;
                     memcpy(c->crypto_ctx.iv, seg->iv, sizeof(seg->iv));
@@ -2663,6 +2830,12 @@ static int hls_read_seek(AVFormatContext *s, int stream_index,
     int64_t first_timestamp, seek_timestamp, duration;
     int64_t seq_no, seg_start_ts;
 
+    /* Kazumi: Mark that we're seeking - reset ad filtering state */
+    c->after_seek = 1;
+    c->in_ad_segment = 0;
+    c->video_resumed = 0;
+    c->audio_resumed = 0;
+
     if ((flags & AVSEEK_FLAG_BYTE) || (c->ctx->ctx_flags & AVFMTCTX_UNSEEKABLE))
         return AVERROR(ENOSYS);
 
@@ -2824,6 +2997,10 @@ static const AVOption hls_options[] = {
         OFFSET(seg_format_opts), AV_OPT_TYPE_DICT, {.str = NULL}, 0, 0, FLAGS},
     {"seg_max_retry", "Maximum number of times to reload a segment on error.",
      OFFSET(seg_max_retry), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, FLAGS},
+    {"hls_ad_filter", "Filter ad segments based on PTS discontinuity (Kazumi)",
+        OFFSET(hls_ad_filter), AV_OPT_TYPE_BOOL, {.i64 = 0}, 0, 1, FLAGS},
+    {"seg_allow_img", "Allow segments detected as gif and png images, 0 = disable, 1 = enable",
+        OFFSET(seg_allow_img), AV_OPT_TYPE_BOOL, { .i64 = 0}, 0, 1, FLAGS},
     {NULL}
 };
 
